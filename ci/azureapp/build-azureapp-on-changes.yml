trigger:
  branches:
    include: ['feature/*']
  paths:
    include: ['src/azureapp/*']

name: 'build-azureapp-on-changes'
variables:
  # This variable is set during runtime
  revision:
  # We use a 'shared' management environment to host docker containers.
  # This would ensure that production would get the same image that was tested on staging
  subscriptionName: 'main'
  environment: 'management'
  stage:       'truehhart'
  appName:     'azureapp'

stages:
# This stage is focused around building the application.
# We could also sqeeze in the deployment in here, but generally in practice it proved better to split resources logically.
# As such, I have decided to have CI and CD pipelines to be separate.
- stage: 'build'
  displayName: 'Building $(appName)'
  jobs:
  - job: 'build_and_push_container'
    pool: 'localhost'
    steps:
    # I want all containers to not only be tagged with the build order number, but also include the git revision.
    # Helps with identification and can be used in the future for troubleshooting, etc.
      - task: CmdLine@2
        displayName: '[Build] Getting current git revision'
        inputs:
          script: 'x=`echo "$(Build.SourceVersion)" | head -c 7`; echo "##vso[task.setvariable variable=revision]$x"'

      # I've decided to go with the @1 revision of the Docker task to streamline the pipeline.
      # Docker@2 would require setting up a container registry connection before being able to push images.
      # Docker@1 only requires the subscription connection. So we can just set up Azure SC 1 time and forget about it.
      - task: Docker@1
        displayName: '[Build] Building ${{ variables.appName}} container image'
        inputs:
          containerregistrytype: 'Azure Container Registry'
          azureSubscriptionEndpoint: '$(subscriptionName)-sc'
          command: 'Build an image'
          imageName: '$(Build.Repository.Name):$(Build.BuildId).$(revision)'
          Dockerfile: 'build/dockerfiles/$(appName).Dockerfile'
          buildContext: '$(Build.Repository.LocalPath)'
          azureContainerRegistry: '$(environment)$(stage)acr.azurecr.io'

      # Note that we are pushing the container to the management repository.
      - task: Docker@1
        displayName: '[Build] Pushing ${{ variables.appName }}:${{ variables.Build.BuildId }}.${{ variables.revision }} to container registry'
        inputs:
          containerregistrytype: 'Azure Container Registry'
          azureSubscriptionEndpoint: '$(subscriptionName)-sc'
          command: 'Push an image'
          imageName: '$(Build.Repository.Name):$(Build.BuildId).$(revision)'
          # buildContext: '$(Build.Repository.LocalPath)'
          azureContainerRegistry: '$(environment)$(stage)acr.azurecr.io'